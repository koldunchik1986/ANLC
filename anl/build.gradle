plugins {

    id 'com.android.application'
    id 'kotlin-android'
}
import java.text.SimpleDateFormat

// --- BACKUP TASK ---
tasks.register('backupGitRelease') {
    doLast {
        try {
            def backupRoot = new File(rootDir, "backup")
            if (!backupRoot.exists()) backupRoot.mkdirs()
            def changesLast = new File(backupRoot, "changes_last.md")
            def changesNew = new File(backupRoot, "changes_new.md")
            if (!changesLast.exists()) changesLast.text = ""
            def timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date())
            def releaseDir = new File(backupRoot, "${timestamp}")
            releaseDir.mkdirs()

            // Константа: список файлов и папок для бэкапа
            def pathsToBackup = [
                'app/build.gradle',
                'app/src/',
                'gradle/',
                'build.gradle',
                'settings.gradle',
                'gradlew',
                'gradlew.bat',
                'local.properties',
                'build-release.bat',
                'proguard-rules.pro',
                'readme.md'
            ]

            // Собираем хеши только для указанных файлов/папок
            def allFiles = []
            pathsToBackup.each { relPath ->
                def absPath = new File(rootDir, relPath)
                if (absPath.exists()) {
                    if (absPath.isFile()) {
                        allFiles << absPath
                    } else if (absPath.isDirectory()) {
                        absPath.eachFileRecurse { f -> if (f.isFile()) allFiles << f }
                    }
                }
            }
            def sha256 = { file ->
                def md = java.security.MessageDigest.getInstance("SHA-256")
                def buf = new byte[8192]
                file.withInputStream { is ->
                    int n
                    while ((n = is.read(buf)) > 0) md.update(buf, 0, n)
                }
                return md.digest().collect { String.format("%02x", it) }.join("")
            }
            def changesNewList = []
            allFiles.each { file ->
                def relPath = file.absolutePath.substring(rootDir.absolutePath.length()+1).replace('\\','/')
                try {
                    def hash = sha256(file)
                    changesNewList << "- ${relPath} | ${hash}"
                } catch (Exception e) {
                    // Ошибки чтения игнорируем, не выводим
                }
            }
            changesNew.text = changesNewList.join("\n")

            // Читаем предыдущие хеши
            def prevChanges = [:]
            if (changesLast.text.trim()) {
                changesLast.eachLine { line ->
                    def m = line =~ /^- (.+) \| ([a-fA-F0-9]{64})$/
                    if (m) prevChanges[m[0][1]] = m[0][2]
                }
            }

            // Явная логика: если changes_last.md пустой, копируем все файлы
            def filesCopied = []
            def firstRun = prevChanges.isEmpty()
            changesNewList.each { line ->
                def m = line =~ /^- (.+) \| ([a-fA-F0-9]{64})$/
                if (m) {
                    def relPath = m[0][1]
                    def hash = m[0][2]
                    def prevHash = prevChanges[relPath]
                    if (firstRun || prevHash == null || prevHash != hash) {
                        def srcFile = new File(rootDir, relPath)
                        def destFile = new File(releaseDir, relPath)
                        destFile.parentFile.mkdirs()
                        try {
                            srcFile.withInputStream { is ->
                                destFile.withOutputStream { os ->
                                    os << is
                                }
                            }
                            filesCopied << relPath
                        } catch (Exception e) {
                            // Ошибки копирования игнорируем, не выводим
                        }
                    }
                }
            }

            // Копируем changes_new.md в папку релиза
            def destChangesNew = new File(releaseDir, "changes_new.md")
            changesNew.withInputStream { is ->
                destChangesNew.withOutputStream { os ->
                    os << is
                }
            }

            // Обновляем changes_last.md
            changesLast.text = changesNew.text
        } catch (Exception e) {
            println "[BACKUP ERROR] " + e.getMessage()
            e.printStackTrace()
        }
    }
}
preBuild.dependsOn tasks.named('backupGitRelease')
android {
    compileSdkVersion 34
// Автоматическое имя релизного APK: ABClient_v1.0.0.apk
android.applicationVariants.all { variant ->
    if (variant.buildType.name == "release") {
        variant.outputs.all { output ->
            def appName = "ABClient"
            def version = variant.versionName
            outputFileName = "${appName}_v${version}.apk"
        }
    }
}
    namespace 'com.abclient'

    defaultConfig {
    applicationId "com.abclient"
    minSdkVersion 26
    targetSdkVersion 34
    versionCode 1
    versionName "1.0.0"
    resValue "string", "app_version_name", versionName
    }

    signingConfigs {
        release {
            storeFile file("${rootProject.projectDir}/app/koldunchik1986-key.jks")
            storePassword RELEASE_STORE_PASSWORD
            keyAlias RELEASE_KEY_ALIAS
            keyPassword RELEASE_KEY_PASSWORD
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }

    buildTypes {
        release {
            signingConfig signingConfigs.release
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
        debug {
            debuggable true
        }
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.0"
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'
    implementation 'com.squareup.okhttp3:logging-interceptor:4.12.0'
}